"use strict";(self.webpackChunkpenless_docs=self.webpackChunkpenless_docs||[]).push([[875],{9613:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(9496);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(a),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||s;return a?n.createElement(h,r(r({ref:t},c),{},{components:a})):n.createElement(h,r({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,r=new Array(s);r[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var p=2;p<s;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7821:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(6920),i=(a(9496),a(9613));const s={},r="API Design Principles",o={unversionedId:"design/api",id:"design/api",title:"API Design Principles",description:"Overview",source:"@site/docs/design/api.md",sourceDirName:"design",slug:"/design/api",permalink:"/design/api",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"designSidebar",next:{title:"System Architecture",permalink:"/design/arch"}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Background",id:"background",level:3},{value:"Basic Principles",id:"basic-principles",level:3},{value:"Access Control",id:"access-control",level:3},{value:"API Design",id:"api-design",level:2},{value:"Framework APIs",id:"framework-apis",level:3},{value:"AI APIs",id:"ai-apis",level:3},{value:"API Implementation",id:"api-implementation",level:2},{value:"Basic APIs",id:"basic-apis",level:3},{value:"Admin APIs",id:"admin-apis",level:3},{value:"AI APIs",id:"ai-apis-1",level:3},{value:"Task Tracking",id:"task-tracking",level:3},{value:"App-specific data?",id:"app-specific-data",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"api-design-principles"},"API Design Principles"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("h3",{id:"background"},"Background"),(0,i.kt)("p",null,"As a business platform, we need to provide APIs for our users to build their own apps. The overall architecture of the system can be described as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"framework"),(0,i.kt)("li",{parentName:"ul"},"app"),(0,i.kt)("li",{parentName:"ul"},"APIs")),(0,i.kt)("p",null,"The APIs can be divided into two categories: framework APIs and AI APIs."),(0,i.kt)("p",null,"Given the expected rapid growth of AI APIs, we need to design them in a way that is easy to implement and maintain."),(0,i.kt)("h3",{id:"basic-principles"},"Basic Principles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"APIs and apps should be kept separate. For example, a text2text API does not belong to /chat, which is only the first consumer of the API, but not the owner. When we design and implement the APIs, we need to keep the APIs generic enough and not bound to certain app."),(0,i.kt)("li",{parentName:"ul"},"APIs should be designed as black boxes. They should not be aware of the app that is using them. For example, the text2text API should not be aware of the fact that it is being used by a chat app. The API should be designed as a generic text2text API that can be used by any app."),(0,i.kt)("li",{parentName:"ul"},"AI APIs should be stateless, meaning they do not actively access the context. If they require context, such as configurations or output from previous steps, it should be passed in when called.")),(0,i.kt)("h3",{id:"access-control"},"Access Control"),(0,i.kt)("p",null,"We need to control access to the APIs. This means that we need to know who is using the APIs and what the quota of the APIs is."),(0,i.kt)("p",null,"Each app relies on a set of APIs, and each API has its own access control. Therefore, we can regard each app as a group of APIs to enable APIs in one time. Users do not understand such dependencies. They just want to enable an app, and all the APIs that the app relies on should be enabled automatically."),(0,i.kt)("p",null,"We need to determine which of the following two ways to use:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Two roles: User and API. Access to API1 from App A means that the user is granted access to this API from App B automatically.")),(0,i.kt)("p",null,"The scenario is like this: I need access to API1. You do not need to know how I use this API."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Three roles: User, App, and API. Access to API from App A does not mean that the user is granted access to this API from App B automatically.")),(0,i.kt)("p",null,"The scenario is like this: I need access to API1. And I need to tell you I will be using API1 from App A. I understand that I need to apply for access to API1 from App B separately."),(0,i.kt)("p",null,"Distinguishing the caller of APIs has some key benefits: Data analytics and billing. But this is not related to access control."),(0,i.kt)("h2",{id:"api-design"},"API Design"),(0,i.kt)("p",null,"We can divide the APIs into two categories: framework APIs and AI APIs."),(0,i.kt)("h3",{id:"framework-apis"},"Framework APIs"),(0,i.kt)("p",null,"As we can see, there are two scenarios for using the framework API: platform administration and user self-management. Platform operations will usually affect all the users and thus require higher privileges (which we usually call admin), and user self-management should be kept within their own privilege scope, like a sandbox."),(0,i.kt)("h3",{id:"ai-apis"},"AI APIs"),(0,i.kt)("p",null,"AI APIs are not always provided at an atomic level. In most cases, they are provided as a pipeline, which is a combination of multiple atomic AI APIs. For example, the text2text API is a pipeline composed of text2intent and intent2text APIs."),(0,i.kt)("p",null,"However, we do not want users to be aware of the pipeline. Instead, we aim to provide a unified API for the pipeline, which is text2text."),(0,i.kt)("p",null,"Another consideration is that we may have multiple providers for a certain feature, such as text summarization. For example, we can obtain this feature from providers like ChatGPT and Cloude, as well as from open-source models like LlaMA. For open-source models, there are also different providers, such as ",(0,i.kt)("a",{parentName:"p",href:"http://replicate.com/"},"Replicate.com")," and ",(0,i.kt)("a",{parentName:"p",href:"http://stablediffusionapi.com/"},"stablediffusionapi.com"),", which offer stable diffusion standard APIs. In incorporating all of these options into our platform, we must decide which APIs to call based on their name and parameters. We should not simply list all similar APIs and ask users to choose. This is indeed a challenging task."),(0,i.kt)("p",null,"This principle applies to all AI API design."),(0,i.kt)("h2",{id:"api-implementation"},"API Implementation"),(0,i.kt)("p",null,"We can divide the APIs into framework APIs (can further divided into basic APIs and admin APIs), and AI APIs. For convenience, we do not consider the prefix of the API, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"/api/xxx"),". It will be listed as ",(0,i.kt)("inlineCode",{parentName:"p"},"/xxx"),". "),(0,i.kt)("h3",{id:"basic-apis"},"Basic APIs"),(0,i.kt)("p",null,"These APIs are enabled for all users by default, such as retrieving user profiles. These APIs are safe to be called from the client side (browser, for example)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/user/profile")," - User profile, such as name, email, avatar, etc."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/user/settings")," - User-level settings, including app settings"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/user/plans")," - Subscription plans")),(0,i.kt)("p",null,"We now use PocketBase as the backend, but we do not want to expose the PocketBase API to the client side. We need to provide a unified API for the client side, which is ",(0,i.kt)("inlineCode",{parentName:"p"},"/user/profile"),"."),(0,i.kt)("h3",{id:"admin-apis"},"Admin APIs"),(0,i.kt)("p",null,"These APIs are enabled for admin users by default. And they should not be called from the client side, such as creating a new user."),(0,i.kt)("p",null,"The Admin APIs are listed below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/admin/users")," - User management. Admins are not allowed to change the user data, but can disable a user account, or even delete it completely."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/admin/pricing")," - This is only an example.")),(0,i.kt)("h3",{id:"ai-apis-1"},"AI APIs"),(0,i.kt)("p",null,"The AI industry is constantly evolving, in contrast to management requirements. Because of this, it is difficult to predict the AI functions that will be required in the future, such as video creation, and how developers will use them. Therefore, it is important to design AI APIs that are easy to implement and maintain."),(0,i.kt)("p",null,"Based on the AIGC scenario, all the AI-related APIs are for content creation and manipulation. These APIs process certain inputs and output the results as files. The important factors to consider are the source data type, type of pipeline, and target data type. The general paradigm is: compute(source, target), for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"imagen(text, prompt, image)")," - from a pure idea to result"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"inspire(question, context as prompt, answer)")," - here we can consider context part of prompt"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"extract(image, prompt, text)")," - Understand the input, mostly an image, but can also be a pdf or video content"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-`transform(image,",metastring:"prompt, image)` - Convert the input to another format, such as image to video based on the requirement from the prompt~~~","prompt,":!0,"image)`":!0,"-":!0,Convert:!0,the:!0,input:!0,to:!0,another:!0,"format,":!0,such:!0,as:!0,image:!0,video:!0,based:!0,on:!0,requirement:!0,from:!0,"prompt~~~":!0},"")))),(0,i.kt)("p",null,"Thus, we can unify the APIs as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Endpoint: The feature, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"/imagine")," for text2image processing"),(0,i.kt)("li",{parentName:"ul"},"A JSON object includes the required parameter:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"source, such as ",(0,i.kt)("inlineCode",{parentName:"li"},'source: { type: "image", data: { type: "image/png", src: "https://abc.com/a.png" }}')),(0,i.kt)("li",{parentName:"ul"},"prompts, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"prompts: { prompt: \u201cpositive prompt\u201d, negative: \u201cnegative prompt\u201d }}")))),(0,i.kt)("li",{parentName:"ul"},"Target as response body, such as ",(0,i.kt)("inlineCode",{parentName:"li"},'target: { type "image", data: { type: "image/png", src: "https://abc.com/b.png" }}'))),(0,i.kt)("p",null,"To maintain stable APIs, we should make them strong enough, even if it may not be the most convenient for users. Then, we can provide convenience through the SDK, achieving a balance between stability and adaptability."),(0,i.kt)("h3",{id:"task-tracking"},"Task Tracking"),(0,i.kt)("p",null,"The previous design lacked a critical consideration: performance. This is because AI APIs are usually time-consuming. To address this issue, we need to provide a way to track the processing status and receive partial results as early as possible. Therefore, we should consider two things:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Asynchronous processing"),(0,i.kt)("li",{parentName:"ol"},"Status tracking and partial result retrieval")),(0,i.kt)("p",null,"We have two cases to investigate: OpenAI and Replicate. Both provide a task tracking mechanism."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"OpenAI: In the core API ",(0,i.kt)("inlineCode",{parentName:"li"},"/v1/completions"),", the parameter ",(0,i.kt)("inlineCode",{parentName:"li"},"stream")," is used to enable partial response retrieval. The ",(0,i.kt)("inlineCode",{parentName:"li"},"[DONE]")," signal in the stream indicates the completeness of the conversation."),(0,i.kt)("li",{parentName:"ul"},"Replicate: In the core API ",(0,i.kt)("inlineCode",{parentName:"li"},"/v1/predictions"),", progress is updated to the caller in multiple ways. A webhook is used as a callback in a passive way, and an ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," is used as a status tracking reference. Calling ",(0,i.kt)("inlineCode",{parentName:"li"},"/v1/predictions/<id>")," actively updates the progress and partial result (e.g., 2 of 4 expected generated images).")),(0,i.kt)("p",null,"We can consolidate the above approaches into the following APIs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/api/ai/<feature>")," - The feature, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"/api/ai/imagine")," for text-to-image processing"),(0,i.kt)("li",{parentName:"ul"},"If it's a long-running task, the response body should include an ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," for tracking the status."),(0,i.kt)("li",{parentName:"ul"},"If it's a streamable task, it should contain a boolean parameter named ",(0,i.kt)("inlineCode",{parentName:"li"},"stream"),". The caller can enable HTTP streaming and wait for the completion signal ",(0,i.kt)("inlineCode",{parentName:"li"},"[DONE]"),"."),(0,i.kt)("li",{parentName:"ul"},"If it's a long-running non-streamable task (such as image generation), it should support the ",(0,i.kt)("inlineCode",{parentName:"li"},"GET")," method with ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," as a URL parameter (such as ",(0,i.kt)("inlineCode",{parentName:"li"},"GET /v1/predictions/{id}"),") to retrieve the status and partial result.")),(0,i.kt)("p",null,"For user experience considerations, the front end should display a progress bar or something to manage user expectations. This is not a required feature of the API, but should include progress-related information in the status response body whenever possible."),(0,i.kt)("h3",{id:"app-specific-data"},"App-specific data?"),(0,i.kt)("p",null,"Is it possible to keep all APIs non-app related? We can take this scenario as a research object."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"App specific settings? E.g., a user choose the dimension of image output"),(0,i.kt)("li",{parentName:"ul"},"App default settings? Such as the default value of a listbox, say, default output dimensions")),(0,i.kt)("p",null,"These sounds are not a big deal and can fit into the scope of the three APIs mentioned above. When we develop a new app, we should consider ourselves a developer from outside. Ask ourselves two questions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Do these existing APIs not meet my requirements, or is it simply that I do not know how to use them? For instance, most APIs are designed for data operations, and data can be classified into either user or platform level. With a ",(0,i.kt)("inlineCode",{parentName:"li"},"/user/settings/app/<appid>/<key>"),", you can cover almost everything you need."),(0,i.kt)("li",{parentName:"ul"},"If it's true that we need to create app-specific APIs, does that relate to this platform? If not, feel free to deploy whichever platform you prefer. Railway and Vercel are both good choices.")),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"This document covers the background, basic principles, and general implementations of our APIs. Our goal is to create an elegant API system that remains clean and doesn't grow too quickly."),(0,i.kt)("p",null,"We will face challenges with SDK implementation, particularly in the scenario of code generation. This is an area where AI can be extremely helpful."))}u.isMDXComponent=!0}}]);